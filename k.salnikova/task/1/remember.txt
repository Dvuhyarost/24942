    Getopt работает слева направо, но задание требует справа налево
Поэтому: 1 проход - собираем опции с конца в массив 
2 проход - выполняем в собранном порядке




  Про реальные и эффективные ID

RUID - кто запустил программу (паспорт)
EUID - под кем выполняется (пропуск)
Использование: SUID-программы (passwd, sudo)


Real Group ID (RGID) - Моя основная группа

getgid()  // Real Group ID

Effective Group ID (EGID) - Под чьей группой работаю
getegid()  // Effective Group ID  


        setpgid(0, 0);  // Создать новую группу с текущим процессом как лидером
// Нужно для: управления сигналами, job control в shell


        // atoi - нет проверки ошибок
        // strtol - можно проверить корректность ввода
        if (endptr == value) { /* ошибка */ }
        if (*endptr != '\0') { /* мусор в строке */ }

       setrlimit обработка ошибок
EPERM - нет прав
EINVAL - неверное значение
Обработка: проверка возвращаемого значения + perror



    ulimit.  ограничения помимо FSIZE и CORE


RLIMIT_CPU    // Макс. время CPU
RLIMIT_DATA   // Макс. размер данных
RLIMIT_STACK  // Макс. размер стека
RLIMIT_NOFILE // Макс. число открытых файлов


        Core-файл - дамп памяти при аварийном завершении

Нужен для отладки (как черный ящик)

Размер 0 - на многих системах отключен по умолчанию для безопасности



        переменные окружения отличаются от аргументов командной строки

Аргументы - передаются конкретной программе
Переменные окружения - наследуются всеми дочерними процессами



        если передать -U 9999999999999999999?"

// strtol вернет LONG_MAX, установится ERANGE
// Программа установит максимально возможное значение


        Ulimit - влияет только на текущий процесс и его детей

Переменные окружения - только на текущий процесс и его детей

После завершения - все изменения теряются



        дочерний процесс  НЕ может изменить ulimit родителя

каждый процесс имеет свои ограничения

Изменения не влияют на родительский процесс




        setpgid(0, 0) не всегда будет успешным 

он может вернуть EPERM (нет прав)

Или в слцчае если процесс уже лидер сессии



        когда процесс вызывает setpgid(0, 0)


Процесс создает новую группу

Становится лидером этой группы

PGID становится равным PID

Может управлять сигналами для всей группы


gcc -o process_info program.c


# Показать справку
./process_info

# Показать ID пользователя и группы
./process_info -i

# Стать лидером группы процессов
./process_info -s

# Показать ID процесса
./process_info -p

# Показать ulimit
./process_info -u

# Установить ulimit (например, 1024 байт)
./process_info -U 1024

# Показать размер core-файла
./process_info -c

# Установить размер core-файла (например, 2048 байт)
./process_info -C 2048

# Показать текущую директорию
./process_info -d

# Показать переменные окружения
./process_info -v

# Установить переменную окружения
./process_info -V MY_VAR=my_value